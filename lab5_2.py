def str_to_bytes(my_str: str) -> str:
    return ''.join(format(ord(c), '08b') for c in my_str)

def bits2string(b: str) -> str:
    return ''.join(chr(int(''.join(x), 2)) for x in zip(*[iter(b)]*8))

def dvoich(n: int) -> str:
    b = ''
    while n > 0:
        b = b + str(n % 2)
        n = n // 2
    return b


K = ['01000010100010100010111110011000',
    '01110001001101110100010010010001',
    '10110101110000001111101111001111',
    '11101001101101011101101110100101',
    '00111001010101101100001001011011',
    '01011001111100010001000111110001',
    '10010010001111111000001010100100',
    '10101011000111000101111011010101',
    '11011000000001111010101010011000',
    '00010010100000110101101100000001',
    '00100100001100011000010110111110',
    '01010101000011000111110111000011',
    '01110010101111100101110101110100',
    '10000000110111101011000111111110',
    '10011011110111000000011010100111',
    '11000001100110111111000101110100',
    '11100100100110110110100111000001',
    '11101111101111100100011110000110',
    '00001111110000011001110111000110',
    '00100100000011001010000111001100',
    '00101101111010010010110001101111',
    '01001010011101001000010010101010',
    '01011100101100001010100111011100',
    '01110110111110011000100011011010',
    '10011000001111100101000101010010',
    '10101000001100011100011001101101',
    '10110000000000110010011111001000',
    '10111111010110010111111111000111',
    '11000110111000000000101111110011',
    '11010101101001111001000101000111',
    '00000110110010100110001101010001',
    '00010100001010010010100101100111',
    '00100111101101110000101010000101',
    '00101110000110110010000100111000',
    '01001101001011000110110111111100',
    '01010011001110000000110100010011',
    '01100101000010100111001101010100',
    '01110110011010100000101010111011',
    '10000001110000101100100100101110',
    '10010010011100100010110010000101',
    '10100010101111111110100010100001',
    '10101000000110100110011001001011',
    '11000010010010111000101101110000',
    '11000111011011000101000110100011',
    '11010001100100101110100000011001',
    '11010110100110010000011000100100',
    '11110100000011100011010110000101',
    '00010000011010101010000001110000',
    '00011001101001001100000100010110',
    '00011110001101110110110000001000',
    '00100111010010000111011101001100',
    '00110100101100001011110010110101',
    '00111001000111000000110010110011',
    '01001110110110001010101001001010',
    '01011011100111001100101001001111',
    '01101000001011100110111111110011',
    '01110100100011111000001011101110',
    '01111000101001010110001101101111',
    '10000100110010000111100000010100',
    '10001100110001110000001000001000',
    '10010000101111101111111111111010',
    '10100100010100000110110011101011',
    '10111110111110011010001111110111',
    '11000110011100010111100011110010']


H = ['01101010000010011110011001100111',
    '10111011011001111010111010000101',
    '00111100011011101111001101110010',
    '10100101010011111111010100111010',
    '01010001000011100101001001111111',
    '10011011000001010110100010001100',
    '00011111100000111101100110101011',
    '01011011111000001100110100011001']


def shr(x, d):
    '''
    логический сдвиг (>) ВПРАВО на d
    '''
    result = ''
    for i in range(d):
        result += '0'
        t = 0
    for i in range(d,len(x)):
        result += x[t]
        t+=1
    return result

def add_mod2(x,y): # сложение по модулю 2^32
    t = (int(x,2) + int(y,2)) % 4294967296
    t1 = format(t, '032b')
    return t1


def str_or(x,y):
    while len(x) < len(y):
        x = '0' + x
    while len(y) < len(x):
        y = '0' + y
    
    result = ''
    for i in range(len(x)):
        t1 = int(x[i])
        t2 = int(y[i])
        result += str(t1|t2)
    return result


def str_and(x,y):
    while len(x) < len(y):
        x = '0' + x
    while len(y) < len(x):
        y = '0' + y
    
    result = ''
    for i in range(len(x)):
        t1 = int(x[i])
        t2 = int(y[i])
        result += str(t1&t2)
    return result


def str_no(x):
    result = ''
    for i in x:
        if i == '1':
            result += '0'
            continue
        result += '1'
    return result


def xor(x, y):
    while len(x) < len(y):
        x = '0' + x
    while len(y) < len(x):
        y = '0' + y
    
    result = ''
    for i in range(len(x)):
        t1 = int(x[i])
        t2 = int(y[i])
        result += str((t1 + t2) % 2)
    return result

# jopa dodelaj
def rotr(x,d):
    '''
    циклический сдвиг ВПРАВО! на d
    '''
    d1 = abs(d) % len(x)
    return x[-d:] + x[:-d]

message = 'h'
mb = ''.join(format(ord(c),'08b') for c in message)
k = (448 - len(mb) - 1) % 512
kb = '0'*k
len_dvoich = format(len(mb), '064b')
dmb = mb + '1' + kb + len_dvoich

fivetwelveblocks = [dmb[x:x+512] for x in range (0, len(dmb), 512)]
for block in fivetwelveblocks:
        
    M_t = [block[x:x+32] for x in range (0, len(block), 32)]

    w = [0]*64
    for i in range(16):
        w[i] = M_t[i]


    for i in range(16,64):
        a1 = w[i-15]
        t1 = rotr(a1, 7)
        t2 = rotr(a1, 18)
        t3 = shr(a1, 3)
        t4 = xor(t1, t2)
        t5 = xor(t4, t3)
        s0 = t5

        a1 = w[i-2]
        t1 = rotr(a1, 17)
        t2 = rotr(a1, 19)
        t3 = shr(a1, 10)
        t4 = xor(t1, t2)
        t5 = xor(t4, t3)
        s1 = t5

        a1 = w[i-16]
        a2 = w[i-7]
        t1 = add_mod2(a1, s0)
        t2 = add_mod2(a2, s1)
        t3 = add_mod2(t1, t2)
        w[i] = t3

    # print(w[-1]) # тут все ок

    a,b,c,d,e,f,g,h = H

    for i in range(64):
        k1 = rotr(a, 2)
        k2 = rotr(a, 13)
        k3 = rotr(a, 22)
        k4 = xor(k1, k2)
        k5 = xor(k4, k3)
        
        S0 = k5

        k1 = str_and(a, b)
        k2 = str_and(a, c)
        k3 = str_and(b, c)
        k4 = xor(k1, k2)
        k5 = xor(k4, k3)
        
        Ma = k5

        t2 = add_mod2(S0, Ma)

        k1 = rotr(e, 6)
        k2 = rotr(e, 11)
        k3 = rotr(e, 25)
        k4 = xor(k1, k2)
        k5 = xor(k4, k3)
        
        S1 = k5

        k1 = str_and(e, f)
        k2 = str_no(e)
        k3 = str_and(k2, g)
        k4 = xor(k1, k3)
        
        Ch = k4

        k1 = add_mod2(h, S1)
        k2 = add_mod2(Ch, K[i])
        k3 = add_mod2(k1, k2)
        k4 = add_mod2(k3, w[i])

        t1 = k4

        h = g
        g = f
        f = e
        e = add_mod2(d, t1)
        d = c
        c = b
        b = a 
        a = add_mod2(t1, t2)

    H[0] = add_mod2(H[0], a)
    H[1] = add_mod2(H[1], b)
    H[2] = add_mod2(H[2], c)
    H[3] = add_mod2(H[3], d)
    H[4] = add_mod2(H[4], e)
    H[5] = add_mod2(H[5], f)
    H[6] = add_mod2(H[6], g)
    H[7] = add_mod2(H[7], h)


mHASH = H[0] + H[1] + H[2] + H[3] + H[4] + H[5] + H[6] + H[7]
for elem in H:
    print(elem)


t1 = int(mHASH,2)
print(t1)
print(format(t1,'0x'))

